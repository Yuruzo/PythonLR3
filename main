import math

class ShapeError(Exception):
    """Класс для пользовательских исключений."""
    pass

class Shape:
    def __init__(self, identifier: str, x: float, y: float):
        if not identifier:
            raise ShapeError("Идентификатор не может быть пустым")
        self.identifier = identifier
        self.x = x
        self.y = y

    def move(self, dx: float, dy: float):
        self.x += dx
        self.y += dy

    def area(self):
        raise NotImplementedError

class Rectangle(Shape):
    def __init__(self, identifier: str, x: float, y: float, width: float, height: float):
        super().__init__(identifier, x, y)
        if width <= 0 or height <= 0:
            raise ShapeError("Стороны прямоугольника должны быть положительными")
        self.width = width
        self.height = height

    def area(self):
        return self.width * self.height

    def get_bounds(self):
        return (self.x, self.y, self.x + self.width, self.y + self.height)

class Pentagon(Shape):
    def __init__(self, identifier: str, x: float, y: float, side: float):
        super().__init__(identifier, x, y)
        if side <= 0:
            raise ShapeError("Сторона пятиугольника должна быть положительной")
        self.side = side

    def area(self):
        # площадь правильного пятиугольника
        return (1/4) * math.sqrt(5 * (5 + 2 * math.sqrt(5))) * (self.side ** 2)

    def get_bounds(self):
        # ограничивающий прямоугольник вокруг пятиугольника
        R = self.side / (2 * math.sin(math.pi / 5))  # радиус описанной окружности
        return (self.x - R, self.y - R, self.x + R, self.y + R)


def compare(t1: Shape, t2: Shape):
    if t1.area() > t2.area():
        return f"{t1.identifier} больше по площади чем {t2.identifier}"
    elif t1.area() < t2.area():
        return f"{t1.identifier} меньше по площади чем {t2.identifier}"
    else:
        return f"{t1.identifier} и {t2.identifier} равны по площади"


def is_intersect(t1: Shape, t2: Shape):
    x1_min, y1_min, x1_max, y1_max = t1.get_bounds()
    x2_min, y2_min, x2_max, y2_max = t2.get_bounds()
    return not (x1_max < x2_min or x2_max < x1_min or y1_max < y2_min or y2_max < y1_min)


def is_include(t1: Shape, t2: Shape):
    x1_min, y1_min, x1_max, y1_max = t1.get_bounds()
    x2_min, y2_min, x2_max, y2_max = t2.get_bounds()
    return x1_min <= x2_min and y1_min <= y2_min and x1_max >= x2_max and y1_max >= y2_max


# Демонстрация
if __name__ == "__main__":
    try:
        rect = Rectangle("Прямоугольник", 0, 0, 10, 5)
        pent = Pentagon("Пятиугольник", 5, 5, 4)

        print("Площадь прямоугольника:", rect.area())
        print("Площадь пятиугольника:", pent.area())
        print(compare(rect, pent))

        print("Пересекаются?", is_intersect(rect, pent))
        print("Пятиугольник внутри Прямоугольник?", is_include(rect, pent))

        pent.move(20, 20)
        print("После перемещения Пятиугольник:")
        print("Пересекаются?", is_intersect(rect, pent))

    except ShapeError as e:
        print("Ошибка:", e)
